<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    
<script>

//	关于js你都了解些什么
基本类型比较简单，包括：Undefined、Null、Boolean、Number和String
			引用类型： 	1、动态属性。JS中对象的属性可以动态的添加并且赋值的 new Object()
						2、复制值
						3、函数传参
						4、类型检测 typeof  instanceof
//数组方法

栈和队列 
1.队列先进先出，栈先进后出。
       2. 对插入和删除操作的"限定"。 栈是限定只能在表的一端进行插入和删除操作的线性表。   
          队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。 
	
    队列操作的方法  shift unshift
    栈操作 pop push
		var list = [0,1,2] 
		shift():删除数组的第一个元素,返回删除的值。这里是0 
		unshift(3,4):把参数加载数组的前面，返回数组的长度。现在list中是3,4,0,1,2，返回值为5
		pop():删除数组的最后一个元素，返回删除的值。这里是2
		push(3):将参数加载到数组的最后，返回数组的长度，现在List中时：0,1,2,3，返回值为4
		concat(3,4):把两个数组拼接起来,返回一个数组副本，值为0,1,2,3,4
		splice(index,howmany,item1,.....,itemX):howmany删除项目数量，item为添加的项目
		sort():是按照字符编码的顺序进行排序,中间加函数可实现乱序 里面传一个函数 a b  a>b 看返回值 返回正值就调换顺序  返回负值不掉换
		reverse():方法用于颠倒数组中元素的顺序。
		join():方法用于把数组中的所有元素放入一个字符串。
		toString() 方法可把数组转换为字符串，并返回结果。加radix，也可以转化成十进制



		//3、字符串上的常见方法
		charCodeAt(index) 方法返回一个整数，代表指定位置字符的Unicode编码。
		fromCharCode(code1,code2...) 方法从一些Unicode字符串中返回一个字符串。 
		charAt(index) 方法返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串。
		slice(start,end) 方法返回字符串的片段。 算头不算尾。
		substring(start,end) 方法用于提取字符串中介于两个指定下标之间的字符。算头不算尾。
		substr(start,length)  方法返回一个从指定位置开始的指定长度的子字符串。
		indexOf(substr,startIndex)方法放回String对象内第一次出现子字符串位置。没有找到子字符串，则返回-1。 
		split(separator,limit) 将一个字符串分割为子字符串，然后将结果作为字符串数组返回。limit该值用来限制返回数组中的元素个数。
		concat(string1,string2...) 方法返回字符串值，该值包含了两个或多个提供的字符串的连接。
		search()方法返回与正则表达式查找内容匹配的第一个字符串的位置。 
		toLowerCase/toUpperCase 改变字符串中的字母大小写



//====================this的指向=========================
        1.谁调用指向谁
        2.定时器那种指向window
        3.call apply
            
            对于apply和call两者在作用上是相同的，但两者在参数上有区别的。
            对于第一个参数意义都一样，但对第二个参数：
            apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。
            如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])

            同时使用apply的好处是可以直接将当前函数的arguments对象作为apply的第二个参数传入
                    
		
       // 1.原型与原型链：
        /原型的定义：
            原型是function对象的一个属性，它定义了构造函数制造出来的对象的公共祖先。
            通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。
            有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，
            这样的原型上还有原型的结构就构成了原型链。
        
            /绝大部分的对象最终都会继承自Object.prototype这个对象。
            并不是所有的对象都有原型
            undefined null也都没有原型。

        当我们通过一个对象改变了原型上的引用值类型的属性的话，那么所有对象的这个属性的值都会随之更改
        但是对象并不能删除原型上的属性。
        谁调用这个方法，这个方法中的this就指向这个调用它的对象。
        /原型链 
        
        有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，这样的原型上还有原型的结构就构成了原型链。
        当我们查找son上的属性的时候，如果son自身有属性，那么就打印出来，如果没有，就向上查找原型father，如果father上面还有这个属性
        ，那么继续向上查找grandfoo，如果有就输出，如果没有就返回undefined。
         这种链式的查询结构就叫做原型链。

        /作用域:
        2.es5的作用域有全局作用域和函数作用域，es6中添加了块级作用域
            函数作用域：
                定义：变量（变量作用域又称为上下文）和函数生效（能被访问）的区域
                JavaScript的函数是可以产生作用域的。
                 有一点要注意的是，如果在函数作用域里面声明变量没有用var的话，那么就声明了一个全局变量。
                 同时，两个不同作用域（除了全局作用域）之间是不能互相访问的
            
        /作用域链
            由于函数可以互相嵌套，作用域之间自然也会产生互相嵌套的关系，这个时候就会产生作用域链。
            当代码在一个环境中执行时，会创建变量对象的一个作用域链来保证对执行环境的有权访问的变量和函数的有序访问
            作用域第一个对象始终是当前执行代码所在环境变量对象

        //对象如何查看构造自身的构造函数

        在prototype里面，有一个隐式的属性叫做constructor，这个属性记录的就是对象的构造器，里面存的就是构造函数。

        console.log(oPerson.constructor); // Person();
        
        
        /3.闭包  
         闭包就是能够读取其他函数内部变量的函数.
         不同作用域之间不能够互相访问，但是我们如果在一个函数内部再定义一个函数，并且这个内部函数与外部函数的变量有关联，
         那么我们就可以通过返回这个内部的函数，然后来访问外部函数里面的变量。
        这个函数返回了一个依赖于这个函数的新函数，也就是说这个没有被销毁的新函数的作用域链中还存在着
        对原本函数的作用域的引用，就导致我们原本的函数的上下文不会被销毁，
        我们称返回的这个新函数是原本函数的闭包函数。


        /闭包的缺点：

            1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，
            所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。
            解决方法是，在退出函数之前，将不使用的局部变量全部删除。 

        /立即执行函数
        是解闭包的一个重要方法。但是注意闭包是没有办法解除的，
        我们只能通过另一个新闭包来消除上一个闭包的影响。

        定义：立即执行函数不需要被定义，直接执行，执行完毕之后直接释放。


/继承的几种方式
传统方式使用原型链继承 浪费继承了太多无用属性
1.构造函数 
    用call和apply 改变this指向
2.共享原型
    就是父子构造函数一样
    缺点：无法改变子类原型 要改只能改一个
3.圣杯模式
       
    //原理： 函数的原型等于父级的原型 这样改变一个就不会改变父级属性 
    写一个新的中间的构造函数 把p的原型给f的原型 通过new一个f让他等于c的原型
    共享一下f和p的原型 通过f构造出c的原型  共享原型有一个问题  构造出的对象可以改变原型上的方法
    p=f  C = new F 

    var inherit  = (function(){
        var F = function(){}
        return function(C,P){
            F.prototype = P.prototype;
            C.prototype = new F();
            C.prototype.constructor = C;
            C.prototype.uber = P.prototype;//最后再补充一下 构造完这些 我是由谁来的 就是P.prototype
        }
    }());

//4.预编译

                预编译前奏
                    1.imply global 暗示全局变量
                    .如果任何变量未经声明就赋值使用，此变量就会为全局对象window所有，并且成为window对象的一个属性。
                    2.一切声明的全局变量，都是window的属性。
                    //区别在于：经过声明的全局变量不能通过delete操作来删除，但是未经声明的全局变量可以被删除

				预编译时this指向window。
				1.创建AO对象。
                        首先第一步，创建一个AO对象（执行器上下文）。

                        var AO = {};
                2.寻找形参和变量声明，将变量和形参作为AO对象的属性名添加到对象中，值为undefined。值得注意的是，函数声明不叫变量。

                3.将实参值和形参值相统一。这里因为属性名都已经存在了，所以直接赋值就可以了。

                4.在函数体里面寻找函数声明，将函数名作为属性名，值为这个函数的函数体。

                函数在执行的前一刻会产生一个上下文，这个上下文就是Activeaction Object对象，简称AO对象。

                AO = {}

                这个对象是空的，但是里面有一些我们看不到的却存在的隐式属性，比如this: window属性和arguments: [];属性

                这个对象用来存放一些属性和方法，这些属性和方法就按照前面的四步来产生。

<!--//重绘和重排-->

页面有三个树：DOMTree、CSSTree、renderTree。（实际上多于三个），renderTree上有两个规则：repaint和reflow，重绘和重排。

repaint是元素自身的位置和宽高不变，只改变颜色的之类的属性而不会导致后面的元素位置的变化的时候，renderTree发生的动作。

reflow是元素自身的位置或者宽高改变了从而导致的整个页面的大范围移动的时候，renderTree发生的动作。

所以我们在DOM操作的时候，要尽量避免重排。


<!--//JS异步加载-->
    script标签的特点是会阻塞后面的DOM解析，只有当script标签下载完成并且全部执行完之后，浏览器才会继续解析DOM。
    一旦网速不好，那么整个网站将等待js加载而不进行后续渲染。

    html5标准引入了另一套异步加载js的方法
    以前有一种写法是将script标签写在body的最后面，等在DOM全部解析完成之后才加载js。

    <!--js异步加载的三种方案：-->

        1.defer异步加载

            我们在script标签的行间写一个defer=“defer”或者直接写defer，就可以让这个script变成异步加载了。但是这种异步只是针对下载方面，
            只有等DOMTree全部解析完成（不包括下载完里面的资源）后才会异步执行。而且这个方法只有IE和一些高版本的firefox和chrome可以用。
            
            不过这一种方式可以在script标签里面写代码。

            注意：IE6和IE7的异步加载最多只能有2个，当多余两个的时候必须等前两个加载完才会加载第三个。

            所有defer的js代码都保证按照顺序执行。

        2.async异步加载

            async是asynchronous的缩写，它是html5的标准，下载完成之后就会立即异步执行，这种方法除了IE6-IE8其他的浏览器都好用

            async的js代码不能保证是顺序执行的。

            兼容性写法：

            1.直接写两个script标签，一个是defer，一个是async。

            但是这种方法有缺陷：IE高版本会加载两遍引起冲突，有些浏览器两个都没有会一个都加载不出来。

            所以我们就需要用第二种方法了

• 异步加载js不允许使用document.write这个方法。它会清除文档流，一旦执行就会把全部的标签都清除掉，包括自身的script标签。

        3.w3c的标准规定：动态添加的script标签是异步的。

<!--封装一个兼容性的异步加载js的函数-->
         
function asyncLoaded(url, callback){
	var script = document.createElement('script');
	script.type = 'text/javascript';
	if(script.readyState){//IE和高版本的chrome、firefox    .readyState 对象的状态  非零是读取中
		script.onreadystatechange = function(){
            // onreadystatechange状态改变触发器
			if(script.readyState = 'loaded' || script.readyState == 'complete'){
				script.onreadystatechange = null;
				callback && callback();
			}
		}
	}else{
	script.onload = function(e){//Safari Chrome Opera Firefox
		callback && callback();
		}
	}
	script.src = url;
	document.body.appendChild(script);
}



事件是交互体验的核心功能

    事件是每一个浏览器本来就有的，我们只是给相应的事件添加了一个回调函数。

    拖拽事件
    div.addEventListener('mousedown', function (e){
        var disX = e.clientX - parseInt(getStyle(this, 'left')),
            disY = e.clientY - parseInt(getStyle(this, 'top'));
        document.addEventListener('mousemove', mouseMove, false);
            div.addEventListener('mouseup', function (e) {
                document.removeEventListener('mousemove', mouseMove, false);
            }, false);
        }, false);
        
        function mouseMove(e) {
            div.style.left = e.clentX - disX + 'px';
            div.style.top = e.clientY - disY + 'px';
 
}

绑定事件
    1.句柄方式
        虽然句柄方式的兼容性很好，但是一个元素的一种事件只能绑定一个函数。
        事件监听就会把处理函数放入执行队列，等待js引擎来执行。

    2.ele.addEventListener(type, handle, false)方法。
        一种事件可以绑定多个函数，但是同一个处理函数只能绑定一次。 IE9以下不兼容。
        第一个参数是事件类型，第二个参数是处理函数，第三个参数是是否捕获。

    3.ele.attachEvent(‘on’ + type, handle)
        这个方法是IE独有的方法，一个事件同样可以绑定多个处理函数。
        当同一个函数绑定多次的时候，addEventListener是只执行一次，但是attachEvent会绑定几次执行几次。

        试题：使用原生js，addEventListener，为每一个li绑定一个点击事件，输出他们的顺序。
        这里就要注意这个题考察的不仅仅是绑定事件，更多的是闭包的运用。

         
        var $Li = document.getElementsByTagName('li');
        for (var i = 0, len = $Li.length; i < len; i++) {
        (function (n) {
            $Li[n].addEventListener('click', function () {
                    console.log(n);
            },false);
        } (i))
    }

事件处理程序的运行环境
    1.句柄绑定方式中，函数里面的this指向元素本身。

    2.addEventListener方式中，函数里面的this也是指向元素本身。

    3.attachEvent中，函数里面的this指向的是window而不是元素本身，这算是IE的一个BUG。
    针对这种情况，我们就需要把函数提取出来，然后在attachEvent的时候用call来改变函数内部this的指向。

        兼容性的事件绑定函数
        function attachEvent(ele, type, handle) {
            if (ele.addEventListener) {
                ele.addEventListener(type, handle, null);
            }else if (ele.attachEvent) {
                ele['temp' + type + handle] = handle;
                ele[type + handle] = function () {
                    ele['temp' + type + handle].call(ele);
                };
                ele.attachEvent('on' + type, ele[type + handle]);
            }else {
                ele['on' + type] = handle;
            }
        }

    IE的方法中我们用了一个匿名函数，这样这个函数就无法解除绑定了，因此可以优化成命名函数。

    
解除事件处理程序
    1.句柄方式
        ele.onclick=null
         这样很简单的就可以解除绑定的事件处理函数了。
    
    2.ele.removeEventListener(type, handle, false)

    针对的addEventListener的解除绑定。

    但是这里要注意，只有命名函数才可以解除绑定，当绑定的函数是匿名函数的时候，是没有办法解除绑定的。


    3.ele.detachEvent(‘on’ + type, handle)

    针对IE的attachEvent的解除绑定。

    也是同一个函数才可以解除绑定，匿名函数无法解除绑定


解除绑定事件
function remvoeEvent(ele, type, handle) {
      if(ele.removeEventListener) {
            ele.removeEventListener(type, handle, false);
      }else if (ele.detachEvent) {
            ele.detachEvent('on' + type, handle);
      }else {
            ele['on' + type] = null;
      }
}





事件处理模型——事件冒泡、事件捕获
   1. 什么叫冒泡？

    在结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，子元素冒泡向父元素，结构上的自底向上。

    大部分事件都有事件冒泡现象，并且所有的浏览器都有事件冒泡。
    并不是所有的事件都有冒泡，focus、blur、change、submit、reset、select等方法就没有事件冒泡现象。

    addEventListener最后一个参数就是是否开始事件捕获，当我们填true的时候，就代表开启了事件捕获。只要开启了事件捕获，
    就不会冒泡了，如果不捕获的话，就遵循事件冒泡。因为addEventListener只有chrome有，因此事件捕获也只有chrome浏览器有。

    当事件冒泡和事件捕获同时存在的时候，事件冒泡和事件捕获的触发顺序则为：先捕获，再冒泡。

    2.取消冒泡和阻止默认事件
         1.w3c标准方法：event.stopPropagation()
            IE9以及以下的版本不支持这个方法。

         2.event.cancelBubble = true
            这个属性是IE的，不过一些高版本的浏览器也有这个属性，只要让这个属性的值等于true，同样也可以取消事件冒泡。

            封装一个兼容性的取消事件冒泡的方法：
             
 
                    function stopBubble(event) {
                        if(event.stopPropagation) {
                            event.stopPropagation();
                        }else {
                            event.cancelBubble = true;
                        }
                    }

    3.默认事件

        当我们在浏览器中点击右键，会弹出一个菜单，这就是一个默认事件contextmenu。还有a标签，即使我们不写跳转的页面，
        也会自动刷新页面，这也是一个默认事件。

        移动端的默认事件更多。

        默认事件有好的也有不好的，这就需要我们把不需要的默认事件阻止掉。


    4.阻止默认事件

            1.return false
                我们只要在处理函数最后写上 return false就可以阻止默认事件了,这种写法只能用在句柄方式绑定的事件上。

            2.e.preventDefault()
                 这是w3c标准的阻止默认事件的方法，句柄也同样可以使用。不过IE9以下不兼容。

            3.e.returnValue = false
                这个是IE的方法，事件源对象上的属性returnValue代表是否有默认事件，直接返回false就可以阻止
                默认事件了。现在高版本的浏览器也有这个属性。
            
            封装一个兼容性的阻止默认事件的方法             
            function cancelHandler(event) {
                if(event.preventDefault) {
                    event.preventDefault();
                }else{
                    event.returnValue = false;
                }
            }

事件对象
    在IE中，系统不会把事件对象传到方法中，因此我们的参数e或者event在IE中是不好用的，IE会把事件对象传递到window.event上，
    所以当我们使用事件对象的时候，就要写兼容性的写法：
         
                var event = e || window.event;

事件委托
    事件源对象
        我们现在有一个ul，下面有十万个li，当我们给父级的ul添加第一个点击事件之后，由于事件冒泡的存在，不论我们点击哪一个li都会
        调用父级的点击事件处理函数，这个时候触发父级ul的点击函数的那个li就被称之为事件源对象。

        event.target 是火狐的获取事件源对象

        event.srcElement 是IE的获取事件源对象

        chrome两种都有

    事件源对象的时候也需要写兼容性写法

         
        oUl.addEventListener('click', function (e) {
            //获取事件对象
            var event = e || window.event;
            //获取事件源对象
            var tar = event.target || event.srcElement;
                console.log(tar);
            }, false);

我们利用事件源对象和事件冒泡来处理的方式就叫做事件委托。

事件委托的优点：

1.性能 不需要循环所有的子元素一个个绑定事件

2.灵活 当有新的子元素被加入的时候不需要重新绑定事件





// <!--JS加载时间线（performace timing line）-->
//     1、创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。
//         这个阶段document.readyState = ‘loading’。
//     2、遇到link外部css，创建线程加载，并继续解析文档。
//     3、遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。
//     4、遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。 对于async属性的脚本，脚本加载完成后立即执行。
            （异步禁止使用document.write()）,而defer是等DOMTree解析完成后才执行
//     5、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。
//     6、当文档解析完成，document.readyState = ‘interactive’。
//     7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,
//     但同样禁止使用document.write()）;
//     8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，
//     转化为事件驱动阶段。
//     9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window
//     对象触发load事件。
//     10、从此，以异步响应方式处理用户输入、网络事件等


<!--// 什么叫做DOM呢？-->

//  DOM的全称是Document Object Model 文档对象模型，DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。

//  DOM对象即为宿主对象，由浏览器厂商定义，用来操作html的css功能的一类对象和集合。不过浏览器厂商之间大部分都遵循w3c标准



			

				继承圣杯模式
				var inherit = (function (){
					var F = function(){};
					return function (C,P){
							F.prototype = P.prototype;
							C.prototype = new F();
							C.prototype.constructor = C;
							C.prototype.uber = P;
					}
				}());



				深层克隆
				function deepCopy(src,tar){
					var tar= tar|| {} ;
					for (var prop in src){
							if (typeof (src[prop]) == 'object'){
								tar[prop] = (src[prop].constructor === Array ) ? [] : {};
								deepCopy(src[prop],tar[prop]);
							}else {
								tar[prop] = src[prop];
							}
					}
				
					return tar;
				}


                14： 如何将数组去重说说你的思路
			Array.prototype.unique = function () {
		      var len = this.length,
		      arr = [],
		      obj = {};
		      for (var i = 0; i < len; i++) {
		            if (!obj[this[i]]) {
		                  obj[this[i]] = 1;
		                  arr.push(this[i]);
		            }
		      }
		      return arr;
			}
		用一个空数组和空对象以及一个循环就可实现
		当我们数组中的这个数据出现过一次之后，我们就在obj中将这个元素的值的位置标记成1，后面如果出现相同的属性值，因为这个位置已经是1了，
		所以就不会添加到新数组里面，从而达到了去重的效果。

 




//日期对象-->

    
    // Date()	返回当日的日期和时间。
    // getDate()	从 Date 对象返回一个月中的某一天 (1 ~ 31)。
    // getDay()	从 Date 对象返回一周中的某一天 (0 ~ 6)。
    // getMonth()	从 Date 对象返回月份 (0 ~ 11)。
    // getFullYear()	从 Date 对象以四位数字返回年份。
    // getYear()	请使用 getFullYear() 方法代替。
    // getHours()	返回 Date 对象的小时 (0 ~ 23)。
    // getMinutes()	返回 Date 对象的分钟 (0 ~ 59)。
    // getSeconds()	返回 Date 对象的秒数 (0 ~ 59)。
    // getMilliseconds()	返回 Date 对象的毫秒(0 ~ 999)。
    // getTime()
    // setDate()	设置 Date 对象中月的某一天 (1 ~ 31)。
    // setMonth()	设置 Date 对象中月份 (0 ~ 11)。
    // setFullYear()	设置 Date 对象中的年份（四位数字）。
    // setYear()	请使用 setFullYear() 方法代替。
    // setHours()	设置 Date 对象中的小时 (0 ~ 23)。
    // setMinutes()	设置 Date 对象中的分钟 (0 ~ 59)。
    // setSeconds()	设置 Date 对象中的秒钟 (0 ~ 59)。
    // setMilliseconds()	设置 Date 对象中的毫秒 (0 ~ 999)。
    // setTime()	以毫秒设置 Date 对象。

    // 日期对象也是javascript的内置对象之一，我们可以直接使用。
    // 注意
       // getTime方法返回从1970年1月1日到现在的毫秒数，这个时间我们称之为时间戳。
        //getMonths方法返回的是0-11，我们要获取当前月份的时候记得加一。

//JS定时器  -->
    // 在javascript中，与定时器有关的方法是：

    // setInterval、clearInterval

    // 以及

    // setTimeout、clearTimeout

    // 这些方法都是定义在window对象上面的，因此我们写window.setInterval和解setInterval的意思是一样的，前面的window可以省略掉。

    //     1.setInterval这个定时器的功能是每过一段时间，就把我们想要执行的函数放到js的执行队列中等待执行。因为执行队列不一定是空的，
    //     需要等执行队列中的所有任务都执行完之后才会执行我们的函数，因此这个函数执行的时间也会有细微的差别。
    //         里面的this默认指向window
    //         setInterval其实很消耗内存，这个定时器一旦执行，就不会终止，因此需要我们的内核一直监听这个函数。

    //         定时器其实会返回一个标记，这个标记就是定时器的序号数，我们可以通过定时器的这个标记来清除掉相对应的定时器。
    //         凡是写定时器，一定要清除定时器！

    //     2.有时候我们只需要这个函数延迟一段时间执行，并不需要专门开启一个定时器，这个时候就需要用到setTimeout了
    //         只是这个方法只是把函数延迟一段时间之后执行一次而已。
    //         同时它也有clearTimeout，当我们不想让这个函数执行了，提前把它clear掉就可以了。


//查看滚动条滚动距离-->

    // js中有两套方法可以查看当前滚动条的滚动距离。

    // 第一套是这样的：

    // window.pageXOffset/window.pageYOffset

    // 这个方法可以查看滚动条的横轴和纵轴的滚动距离，但是很遗憾的是IE8以及以下的版本不兼容

    // 因此针对于IE，但是这两个方法不仅仅是IE才可以使用。我们就需要有第二套方法：

    // document.body.scrollLeft/doucment.body.scrollTop

    // document.documentElement.scrollLeft/document.documentElement.scrollTop

    // 这里要说明的是，这两种方法要一起使用，因为浏览器的兼容性问题，有的浏览器是document.body有值，有的是document.documentElement有值
    // ，但是所有的浏览器都只有一个有值，不会两个都有或者一个都没有，而且这里的没有值不代表是null，而是0，因此我们使用的时候一般都是两个一起使用。

//兼容滚动条滚动距离的方法：-->
function getScrollOffset(){
      if(window.pageXOffset) {
            return {
                  x: window.pageXOffset,
                  y: window.pageYOffset
            }
      }
      return {
            x: document.body.scollTop + document.documentElement.scrollTop,
            y: document.body.scrollLeft + document.documentELement.scrollLeft;
}

//查看视口的尺寸-->
// 视口就是我们的可视区，如何来查看当前浏览器的可视区大小？

// 这里我们依然有两套方法：
    1.window.innerHeight/window.innerWidth;
        这个方法可以直接获取到当前可视区的宽高，但是依然很遗憾的是IE8以及以下的版本不兼容。
    
    2.在标准模式下，
        doucment.documentElement.clientWidth/document.documentElement.clientHeight  在任何浏览器都兼容

        在怪异模式（混杂模式）下，*****************************************

        document.body.clientWidth/document.body.clientHeight

        才能查看视口大小，而不能使用上面标准模式下的方法。


什么是怪异模式和标准模式呢？

    浏览器的渲染模式有两种：标准模式和怪异模式。我们常用的是标准模式，怪异模式是防止浏览器升级版本过高对后面版本的代码不兼容，
    让浏览器可以向后兼容其他低版本的代码的法规则，比如IE6的怪异模式下可以兼容IE5个IE4的语法。

    //•  我们如何变成怪异模式呢？

    其实很简单，只需要把我们html代码的第一行的<!DOCTYPE HTML>去掉就可以变成怪异模式了，而加上这一行代码就可以变成标准模式。

    如何判断怪异模式还是标准模式？

   <!--// document上中有一个方法叫做compatMode，当浏览器处于怪异模式的时候会返回字符串“BackCompat”，在标准模式下可以返回“CSS1Compat”，
    通过这个方法我们就可以判断了。-->

     
  function getViewportOffset () {
      if(window.innerWidth) {
            return {
                  w: window.innerWidth,
                  h: window.innerHeight
            }
      }
      if(document.compatMode == 'CSS1Compat') {
            return {
                  w: document.documentElement.clientWidth,
                  h: document.documentElement.clientHeight
      }else {
            return {
                  w: document.body.clientWidth,
                  h: document.body.clientHeight
            }
      }
}  

<!--//查看元素的几何尺寸-->
domEle.getBoundingClientRect()

    在获取的dom元素上，有一个getBoundingClientRect方法，这个方法可以获取到元素的宽高和左上点的位置以及右下点的位置
    （width、height、top、left、right、bottom），老版本的IE浏览器没有实现width和height，那么我们在老版本的IE计算宽高的时候就
    需要用bottom-top和right-left来计算宽高值了。
//注意这里的宽高是指除去了margin的盒子模型的宽高。  这里的宽高也不是实时更新的，数据只是一个副本。
 
    Element.getElementOffset() {
        var objData = this.getBoundingClientRect();
        if(objData.width) {
                return {
                    w: objData.width,
                    h: objData.height
                }
        }else {
                return {
                    w: objData.right - objData.left,
                    h: objData.bottom - objData.top
                }
        }
    }
<!--
    //另一个查看元素尺寸的方法-->

    dom.offsetWidth/dom.offsetHeight

    虽然前面有一个ele.getBoundingClientRect()方法，但是由于这个方法名字是在太长了，因此用的并不是非常多
    ，相比较而言，这两个dom元素的属性用的更多一些。

    这里获取的宽高值和上面的一样，都是除去margin后的盒子模型的宽高。


     

<!--//滚动条滚动-->

    //让滚动条滚动的方法有三个：scroll、scrollTo、scrollBy。

    这三个方法都有两个参数，分别是x值和y值。前两个方法的作用一模一样，都是让滚动条滚动到（x，y）的位置，
    //但是最后一个scrollBy有一些区别，它是让滚动条相对于上一个位置滚动多少距离。

    我们可以简单的用这个方法来实现一个自动阅读的功能：

    setInterval(function () {
        scrollBy(0, 10);
    },50);
        
<!--//查看元素的位置-->

dom.offsetLeft/dom.offsetTop

这两个值分别是元素距离左侧和上侧的距离，这里的值是相对于有定位的父级而言的，如果没有有定位的父级的话，才是相对于文档的坐标。

//那么现在就来了一个问题：如何找到有定位的父级呢？

//domEle上面还有一个属性是offsetParent，这个属性可以查看到元素的有定位的父级，如果没有的话就会返回body，而body的offsetParent则是null。

 
Element.prototype.getPosition = function (){
      if (!this.offsetParent){
            return {
                  "w": this.offsetLeft,
                  "h": this.offsetTop
            }
      }
      var width = this.offsetLeft,
            height = this.offsetTop,
            ele = this.offsetParent;
      while (ele.offsetParent){
            width += this.offsetParent.offsetLeft;
            height += this.offsetParent.offsetTop;
            ele = ele.offsetParent;
      }
      return {
            "w": width,
            "h": height
      }
}

<!--//脚本化CSS-->
    读写CSS样式
    每一个dom元素都有一个属性style，dom.style里面存放的这个元素的行间样式，我们可以通过这个属性来读写元素的行间样式。

    1.我们碰到float这样的关键字属性的时候，前面要加一个css前缀。

    float—>cssFloat

    2.复合属性必须拆解

    border: 1px solid red;

    这种属性是不允许出现的，只能写border-width、border-color、border-style。

    3.当css中的样式是用“-”连接起来的时候，我们要变成小驼峰式写法。

    background-color —> backgroundColor;

    这个属性只能读写行间样式，我们写在css的样式是不能获取的，因此我们通过这个属性加样式的时候要注意权重值问题。

    同时，我们在js中写样式只能往行间写，永远也写不到css文件里面。
<!--
//查询计算样式-->
    window上面有一个方法叫做getComputedStyle可以来获取元素的计算样式，也就是css样式。
    window.getComputedStyle(ele. null);
    //这里的样式是取优先级最高的，不只是行间样式，所有的只要是表现出来的样式都可以获取出来。
    同时，返回的计算样式的值都是绝对值，没有相对单位。
   // 第一个参数是我们要获取的元素。第二个参数是一个字符串，代表我们是否要获取这个元素上面的某一个伪元素，
    如果不的话，就填写null，否则就填写要获取的这个元素的哪一个伪元素。



//但是很遗憾的是IE8以及以下的版本不兼容这个方法,IE8有一个特殊的样式currentStyle。
dom.currentStyle也会返回一个样式表，和上面的基本一样，唯一的区别在于返回的计算样式的值不是经过转换的绝对值，而是我们写什么值就会返回什么值
<!--
封装一个兼容性的获取样式的函数-->
    function getStyle(obj, prop, fake) {
        var fake = fake || null;
        if(obj.currentStyle) {
            return obj.currentStyle[prop];
        }else {
            return window.getComputedStyle(obj, fake)[prop];
        }
    }

    脚本化样式表

在document上有一个属性叫做styleSheets，这个属性储存了一个html文档所有的css样式表的集合，我们可以来操作style标签，
不过在实际中基本是用不到的，


</script>
</body>
</html>